
var Schema;


function Rule(ruleDef, parentRule) {

  if (ruleDef === null || typeof ruleDef !== 'object') {
    throw new Error('ruleDef must be an object or array');
  }

  if (typeof ruleDef === 'object' && typeof ruleDef.length === 'number') {
    var props = ['key', 'type', 'size', 'schema'];
    var ruleDefArr = ruleDef;
    ruleDef = {};
    for (var i = 0; i < ruleDefArr.length && i < props.length; i += 1) {
      ruleDef[props[i]] = ruleDefArr[i];
    }
  }

  ruleDef.size || (ruleDef.size = null);
  parentRule   || (parentRule   = null);

  if (typeof ruleDef.key !== 'string') {
    throw new Error('ruleDef.key must be a string');
  }
  if (typeof ruleDef.type !== 'string') {
    throw new Error('ruleDef.type must be a string');
  }
  if (ruleDef.size && typeof ruleDef.size !== 'number' && typeof ruleDef.size !== 'string') {
    throw new Error('ruleDef.size must be a number or a string');
  }

  if (parentRule && !(parentRule instanceof Rule)) {
    throw new Error('parentRule must be an instance of Rule');
  }


  var typeDef        = null;
  var schemaRuleDefs = null;
  if (ruleDef.type === 'loop' || ruleDef.type === 'section') {
    Schema || (Schema = require('./schema'));
    schemaRuleDefs = ruleDef.schema;
  } else {
    typeDef = Rule.types[ruleDef.type];
  }

  if (schemaRuleDefs && typeof ruleDef.size !== 'string') {
    throw new Error('type ' + ruleDef.type + ' does not allow a fixed size');
  }

  if (!typeDef && !schemaRuleDefs) {
    throw new Error('unknown type ' + ruleDef.type);
  }
  if (typeDef && typeof typeDef.size !== 'number' && !ruleDef.size) {
    throw new Error('type ' + ruleDef.type + ' requires a size');
  }

  this.val             = null;
  this.size            = -1;
  this.offset          = -1;
  this.isResolved      = false;
  this.isSizeRule      = false;
  this.key             = ruleDef.key;
  this.type            = ruleDef.type;
  this._subValCount    = -1;
  this._schemaOffset   = 0;
  this._parentRule     = parentRule;
  this._typeDef        = typeDef;
  this._schemaRuleDefs = schemaRuleDefs;
  this._schemas        = [];

  if (typeof ruleDef.size === 'string') {
    this._sizeRule = this._getSizeRule(ruleDef.size);
  } else {
    this._ruleDefSize = ruleDef.size;
  }
}

Rule.types = {
  ascii    : require('../type/ascii'),
  base64   : require('../type/base64'),
  doubleLE : require('../type/doubleLE'),
  doubleBE : require('../type/doubleBE'),
  floatBE  : require('../type/floatBE'),
  floatLE  : require('../type/floatLE'),
  hex      : require('../type/hex'),
  int8     : require('../type/int8'),
  int16BE  : require('../type/int16BE'),
  int16LE  : require('../type/int16LE'),
  int32BE  : require('../type/int32BE'),
  int32LE  : require('../type/int32LE'),
  uInt8    : require('../type/uInt8'),
  uInt16BE : require('../type/uInt16BE'),
  uInt16LE : require('../type/uInt16LE'),
  uInt32BE : require('../type/uInt32BE'),
  uInt32LE : require('../type/uInt32LE'),
  utf8     : require('../type/utf8'),
  utf16le  : require('../type/utf16le')
};
Rule.types['utf16-le'] = Rule.types.utf16le;

Rule.prototype._getSizeRule = function(sizeRuleKey) {
  var rule = this._getAncestorRuleByKey(sizeRuleKey);

  if (!rule) {
    throw new Error(
      this.key + ' refers to an ancestor ' + sizeRuleKey + ' but no ancestor ' +
      'exists by that key'
    );
  }

  rule.isSizeRule = true;

  if (rule._typeDef.type !== 'number') {
    throw new Error(
      sizeRuleKey + ' is referenced as a size rule, but it isn\'t a number type'
    );
  }

  return rule;
};

Rule.prototype._getAncestorRuleByKey = function(key) {
  var ancestorRule = this._parentRule;
  while (ancestorRule) {
    if (ancestorRule.key === key) { return ancestorRule; }
    ancestorRule = ancestorRule._parentRule;
  }
  return null;
};

Rule.prototype.encode = function(buf, val, offset) {
  offset || (offset = 0);

  this._ensureAncestorResolution();
  this._calcOffset();

  if (this.type === 'loop') {
    return this._encodeLoop(buf, val, offset);
  }
  if (this.type === 'section') {
    return this._encodeSection(buf, val, offset);
  }

  this._calcSizeForEncode(val);
  if (this._sizeRule) {
    this._sizeRule.encode(buf, this.size, offset);
  }

  return this._encodeVal(buf, val, offset);
};

Rule.prototype._ensureAncestorResolution = function() {
  var ancestorRule = this._parentRule;
  while (ancestorRule) {
    if (!ancestorRule.isResolved) {
      throw new Error(
        ancestorRule.key + ' has not been resolved. It is required as an ' +
        'ancestor of ' + this.key
      );
    }
    ancestorRule = ancestorRule._parentRule;
  }
};

Rule.prototype._calcOffset = function() {
  if (!this._parentRule) {
    this.offset = 0;
  } else {
    this.offset = this._parentRule.offset + this._parentRule.size;
  }
};

Rule.prototype._encodeLoop = function(buf, arr, offset) {
  if (this.isResolved) { return true; }

  this.val || (this.val = []);

  if (this._schemas.length < 1) {
    for (var i = 0; i < arr.length; i += 1) {
      this._schemas.push(new Schema(this._schemaRuleDefs));
    }
  }

  var schemaOffset = 0;
  for (var i = 0; i < this._schemas.length; i += 1) {
    var schema = this._schemas[i];

    if (schema.isResolved) {
      schemaOffset += schema.size;
      continue;
    }

    if (!schema.encode(buf, arr[i], this.offset + schemaOffset + offset)) {
      return false;
    }
    schemaOffset += schema.size;
    this.val[i]   = schema.data;
  }

  this._sizeRule.encode(buf, schemaOffset, offset);

  this.isResolved = true;
  this.size       = schemaOffset;

  return true;
};

Rule.prototype._encodeSection = function(buf, data, offset) {
  if (this.isResolved) { return true; }

  if (this._schemas.length < 1) {
    this._schemas[0] = new Schema(this._schemaRuleDefs);
  }

  var schema = this._schemas[0];

  if (!schema.encode(buf, data, this.offset + offset)) {
    return false;
  }

  this._sizeRule.encode(buf, schema.size, offset);

  this.isResolved = true;
  this.val        = schema.data;
  this.size       = schema.size;

  return true;
};

Rule.prototype._calcSizeForEncode = function(val) {
  var ruleDefSize = null;
  var typeDefSize = null;

  if (typeof this._ruleDefSize === 'number') {
    ruleDefSize = this._ruleDefSize;
  }

  if (typeof this._typeDef.size === 'number') {
    typeDefSize = this._typeDef.size;
  }

  if (typeof typeDefSize === 'number' && typeof ruleDefSize === 'number') {
    if (ruleDefSize % typeDefSize !== 0) {
      throw new Error(
        this.key + ' has a size of ' + ruleDefSize + ' which is not ' +
        'divisible by its type ' + this.type + ' which has a fixed size of ' +
        typeDefSize
      );
    }

    this._subValCount = ruleDefSize / typeDefSize;
    this.size         = ruleDefSize;
  } else {

    if (this._typeDef && typeof this._typeDef.size === 'function') {
      typeDefSize = this._typeDef.size(val);
    }

    this.size = ruleDefSize || typeDefSize;
  }
};

Rule.prototype._encodeVal = function(buf, val, offset) {
  if (buf.length - (offset + this.offset) < this.size) { return false; }

  if (val !== undefined) {

    if (this._subValCount > -1) {
      if (typeof val !== 'object' || typeof val.length !== 'number') {
        throw new Error(
          this.key + ' expects an array of type ' + this._typeDef.type +
          ' but an array was not given'
        );
      }

      if (val.length !== this._subValCount) {
        throw new Error(
          this.key + ' expects ' + this._subValCount +  ' sub vals but got ' +
          val.length + ' instead'
        );
      }

      for (var i = 0; i < this._subValCount; i += 1) {
        if (this._typeDef.type !== typeof val[i]) {
          throw new Error(
            this.key + ' expects all sub vals to be type ' +
            this._typeDef.type + ' but the sub val ' + i + ' is of type ' +
            typeof val[i]
          );
        }

        var _offset = offset + this.offset + (this._typeDef.size * i);
        this._typeDef.encode(buf, val[i], _offset, this.size);
      }
    } else {
      if (this._typeDef.type !== typeof val) {
        throw new Error(
          this.key + ' expects value of type ' + this._typeDef.type + ' but ' +
          'the value is of type ' + typeof val
        );
      }

      this._typeDef.encode(buf, val, offset + this.offset, this.size);
    }

  }

  this.isResolved = true;
  this.val        = val;

  return true;
};

Rule.prototype.decode = function(buf, offset) {
  offset || (offset = 0);

  this._ensureAncestorResolution();
  this._calcOffset();
  this._calcSizeForDecode();

  if (this.type === 'loop') {
    return this._decodeLoop(buf, offset);
  }
  if (this.type === 'section') {
    return this._decodeSection(buf, offset);
  }

  return this._decodeVal(buf, offset);
};

Rule.prototype._decodeLoop = function(buf, offset) {
  if (this.isResolved) { return true; }

  this.val || (this.val = []);

  if (this.size === 0) {
    this.isResolved = true;
    return true;
  }

  var schemaOffset  = 0;
  var pendingSchema = null;
  for (var i = 0; i < this._schemas.length; i += 1) {
    var schema = this._schemas[i];

    if (!schema.isResolved) {
      pendingSchema = schema;
      break;
    }

    schemaOffset += schema.size;
  }

  while (schemaOffset < this.size) {
    var schema;
    if (pendingSchema) {
      schema = pendingSchema;
      pendingSchema = null;
    } else {
      schema = new Schema(this._schemaRuleDefs);
      this._schemas.push(schema);
    }

    if (!schema.decode(buf, this.offset + schemaOffset + offset)) {
      return false;
    }

    this.val.push(schema.data);
    schemaOffset += schema.size;
  }

  this.isResolved = true;

  return true;
};

Rule.prototype._decodeSection = function(buf, offset) {
  if (this.isResolved) { return true; }

  if (this.size === 0) {
    this.isResolved = true;
    return true;
  }

  if (this._schemas.length < 1) {
    this._schemas[0] = new Schema(this._schemaRuleDefs);
  }

  var schema = this._schemas[0];

  if (!schema.decode(buf, this.offset + offset)) { return false; }

  this.isResolved = true;
  this.val        = schema.data;

  return true;
};

Rule.prototype._calcSizeForDecode = function() {
  var ruleDefSize  = null;
  var typeDefSize  = null;

  if (this._sizeRule && typeof this._sizeRule.val === 'number') {
    ruleDefSize = this._sizeRule.val;
  } else if (typeof this._ruleDefSize === 'number') {
    ruleDefSize = this._ruleDefSize;
  }
  if (this._typeDef && typeof this._typeDef.size === 'number') {
    typeDefSize = this._typeDef.size;
  }

  if (typeof typeDefSize === 'number' && typeof ruleDefSize === 'number') {
    if (ruleDefSize % typeDefSize !== 0) {
      throw new Error(
        this.key + ' has a size of ' + ruleDefSize + ' which is not ' +
        'divisible by its type ' + this.type + ' which has a fixed size of ' +
        typeDefSize
      );
    }

    this._subValCount = ruleDefSize / typeDefSize;
    this.size         = ruleDefSize;
  } else {
    this.size = ruleDefSize || typeDefSize;
  }
};

Rule.prototype._decodeVal = function(buf, offset) {
  if (buf.length - (offset + this.offset) < this.size) { return false; }

  var val;
  if (this._subValCount > -1) {
    val = [];
    for (var i = 0; i < this._subValCount; i += 1) {
      var _offset = offset + this.offset + (this._typeDef.size * i);
      val.push(this._typeDef.decode(buf, _offset, this.size));
    }
  } else {
    val = this._typeDef.decode(buf, offset + this.offset, this.size);
  }

  this.isResolved = true;
  this.val        = val;

  return true;
};

Rule.prototype.reset = function() {
  this.val           = null;
  this.isResolved    = false;

  if (this._schema) {
    this._schemaOffset = 0;
    this._schema.reset();
  }
};


module.exports = Rule;
